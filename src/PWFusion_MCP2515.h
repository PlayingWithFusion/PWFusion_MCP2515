/***************************************************************************
* File Name: PWFusion_MCP2515.h
*
* Copyright Â© 2014 Playing With Fusion, Inc.
* SOFTWARE LICENSE AGREEMENT: This code is released under the MIT License.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
* **************************************************************************
* REVISION HISTORY:
* Author          Date        Comments
* J. Leonard      2014Nov10   Original version
* J. Leonard      2022Jan13   Updated to Arduino library folder structure.  Removed
*                             MCP2515Class instantiation from library.  Renamed 
*                             attach() to begin().  Added support for alternative
*                             SPI ports
*
* Playing With Fusion, Inc. invests time and resources developing open-source
* code. Please support Playing With Fusion and continued open-source
* development by buying products from Playing With Fusion!
*
* **************************************************************************/
#ifndef __PWFUSION_MCP2515_H
#define __PWFUSION_MCP2515_H

#include <Arduino.h>
#include <stdlib.h>
#include <SPI.h>


//! Recieved CAN messages are stored internally in a FIFO queue as they are recieved by the MCP2515 to free the hardware buffers.  CAN_RX_QUEUE_LENGTH defines the length of this queue.  Incresing the length of this buffer reduces the risk of dropped CAN messages, but consumes more RAM
#define CAN_RX_QUEUE_LENGTH 8

// Maximum number of instances of this library which may run at the same time (limited by number of avaliable interrupts)
#define MAX_INSTANCES       4

typedef struct can_message_s
{
   uint32_t sid;        // 11 or 29-bit Message Identifier
   uint8_t extended:1;  // 29-bit identifier is used if true
   uint8_t rtr:1;       // remote frame if true
   uint8_t dlc:4;       // Number of data bytes (0-8)
   uint8_t data[8];     // Data bytes
} can_message_t;


class MCP2515
{
   public:
      MCP2515();

      //! Initialize the MCP2515 driver.  This function must be called before any other member functions.
      /*!
        \param chipSpelectPin Arduino pin attached to the chip select input of the MCP2515.  This parameter is passed to pinMode()
        \param interruptPin Arduino pin attached to the MCP2515 interupt pin.  For the UNO.
        \param loopback Boolean value. If true, loopback mode is enables and all transmitted traffic is copped to the recieve buffers.  No messages are transmited over the physical CAN bus.  If false messages are transmitted over the bus normally
        \param bitRate Bit-rate in k bits/s.  Value must be one of: 100, 125, 250, 500, or 1000 (1Mbit).
        \return None
      */
      void begin(uint8_t chipSelectPin, uint8_t interruptPin, uint8_t loopback, uint16_t bitRate, SPIClass &spiPort = SPI);
      
      //! Transmit single CAN message onto bus.
      /*!
        \param pMsg Pointer to can_message_t structure describing message to be sent.
        \return true if message sucessfully queued in one of the MCP2515 transmit buffers.  false if both buffers were full and message was not queued
      */
      uint8_t send(can_message_t *pMsg);
      
      //! Check if a CAN message was received since the last call to receive().  If so the eariliest message is copied to pMsg.  If no new messages are avaliable recieve() returns false.
      /*!
        \param pMsg Pointer to can_message_t structure where recieved message will be stored.
        \return true if a new message was avaliable and copied to pMsg.  false if no new messages are avaliable
      */
      uint8_t receive(can_message_t *pMsg);
      
       //! Private function used internally to respond to interrupts generated by the MCP2515
      void handleInterrupt();


   private:
      void queueRxMessage(uint8_t channel);
      
      can_message_t rxBuffer[CAN_RX_QUEUE_LENGTH];      
      uint8_t chipSelect;  // Chip select pin
      SPIClass *_spiPort;
      SPISettings _spiSettings;
      volatile uint8_t txBufStatus;
      volatile uint8_t rxHead;
      volatile uint8_t rxTail;

      uint8_t getInstanceIdx(uint8_t interrupt);
      static uint8_t interrupts[MAX_INSTANCES];
      static MCP2515 *instances[MAX_INSTANCES];
      friend void MCP2515_RxInt0();
      friend void MCP2515_RxInt1();
      friend void MCP2515_RxInt2();
      friend void MCP2515_RxInt3();
};

#endif // __PWFUSION_MCP2515_H
